#!/usr/bin/env python
import abc
import argparse
import logging
import os.path
import time
import math
from datetime import datetime

import numpy as np
import quaternion

import rospy
from nav_msgs import msg as nm
from geometry_msgs import msg as gm
from sensor_msgs import msg as sm

from visnav.algo import tools
from visnav.algo.model import Camera
from visnav.algo.tools import Pose
from visnav.algo.odo.base import VisualOdometry, Frame, Keypoint
from pyvio import get_logger, Configuration

# DEF_LAT, DEF_LON, DEF_ALT = 60.08879, 24.35987, 0.629

# USAGE:
# e.g. like this:
#   rosrun pyvio vio_node.py --hw-config=../config/nokiapl.yaml \
#                            --imu-config=src/VINS-Fusion/config/nokiapl/imu.yaml -v=2 --to-rviz=1
#   rosrun nokia_navint storage.py --path=/mnt/d/projects/hw_visnav/data/nokia/on_drone/42 --adj-dt=-0.63 \
#                                  --imu-conf=src/VINS-Fusion/config/nokiapl/imu.yaml --type=jouko --skip=50 --wait-odo
#
# or like this:
#   rosrun pyvio vio_node.py --hw-config=aaltopl.yaml \
#                            --imu-config=src/VINS-Fusion/config/aaltopl/imu.yaml -v=2 --to-rviz=1
#   rosrun nokia_navint storage.py --path=/mnt/d/projects/hw_visnav/data/hwproto/f11 --adj-dt=-0.63 \
#                                  --imu-conf=src/VINS-Fusion/config/aaltopl/imu.yaml --type=olli --skip=400 --wait-odo

# TODO:
#  - related to own vio:
#       - start using imu measurements, impl first with run.py and nokia.py
#       /- test async ba
#       /- debug gridded detection


def main():
    parser = argparse.ArgumentParser("visnav interface")
    parser.add_argument('--hw-config', required=True, help="Hardware config file, either in json or yaml")
    parser.add_argument('--imu-config', required=True, help="IMU config file generated by Kalibr")
    parser.add_argument('--vio-config', default='vio-config.yaml', help="VIO config file, either in json or yaml")
    parser.add_argument('--verbosity', '-v', type=int, default=1,
                        help="Verbosity: 0) minimal, 1) logging, 2) plot tracks, 3) plot 3d-map, 4) plot poses")
    parser.add_argument('--to-rviz', type=int, default=0, help='publish debug info for rviz')
    parser.add_argument('--pub-prefix', default="/vins_estimator", help='Prefix for published ROS topics')
    parser.add_argument('--imu-topic', default="/imu0", help='ROS topic to listen for IMU messages')
    parser.add_argument('--cam-topic', default="/cam0/image_raw", help='ROS topic to listen for raw images')
    parser.add_argument('--publish-imu-updates', type=int, default=0, help='Publish also IMU updates to odometry topic')
    # parser.add_argument('--lat', type=float, default=DEF_LAT, help='starting point lat, default %s' % DEF_LAT)
    # parser.add_argument('--lon', type=float, default=DEF_LON, help='starting point lon, default %s' % DEF_LON)
    # parser.add_argument('--alt', type=float, default=DEF_ALT, help='starting point alt, default %s' % DEF_ALT)

    args = parser.parse_args()

    # using other name than 'rosout' doesnt work: https://github.com/ros/ros_comm/issues/1384
    logger = get_logger(None, name='rosout', level=logging.DEBUG)
    logger.info('Initializing VIO...')

    odo = OdometryInterface(args, logger)

    try:
        while not rospy.is_shutdown():
            time.sleep(1)
        logger.info("ROS was shutdown, stopping...")
    except StopIteration:
        logger.info("StopIteration received, stopping...")
    except KeyboardInterrupt:
        logger.info("Ctrl+C received, stopping...")
    finally:
        odo.close()


class OdometryInterface:
    # sub topics:
    #     /cam0/image_raw
    #     /imu0
    #   * /vio_restart

    # pub topics
    #     /vins_estimator/image_track               : sensor_msgs.Image
    #   * /vins_estimator/camera_pose_visual        : visualization_msgs.MarkerArray
    #     /vins_estimator/path
    #     /vins_estimator/point_cloud               : sensor_msgs.PointCloud
    #     /vins_estimator/margin_cloud              : what is this?
    #     /vins_estimator/odometry                  : nav_msgs.Odometry (velocity at odometry.twist.twist.linear.x)

    def __init__(self, args, logger, vio_frame_id='world'):
        self.logger = logger
        self.vio_frame_id = vio_frame_id
        self.config = self._parse_config(args)

        self.to_rviz = args.to_rviz
        self.undist_img = self.config.vio.dictview().pop("undist_img")
        self.vio_width = self.config.vio.dictview().pop("image_width")

        self.cam = Camera(
            self.config.hw.cam.width,  # width in pixels
            self.config.hw.cam.height,  # height in pixels
            cam_mx=self.config.hw.cam.mx,
            undist_proj_mx=None if self.undist_img else self.config.hw.cam.mx,
            dist_coefs=None if self.undist_img else self.config.hw.cam.dist,
        )

        self.config.vio.new_kf_rot_angle = math.radians(self.config.vio.new_kf_rot_angle)

        verbose, suppress_plots = args.verbosity, False
        if args.to_rviz:
            suppress_plots = verbose < 2
            verbose = max(2, verbose)

        self.odo = VisualOdometry(self.cam, self.vio_width, wf2bf=self.config.hw.w2b, bf2cf=self.config.hw.b2c,
                                  # verbose: 0) silent, 1) logging, 2) tracks, 3) 3d-map, 4) poses
                                  verbose=verbose, suppress_plots=suppress_plots,
                                  logger=self.logger, pause=False, **self.config.vio.dictview())

        self.odo._track_image_height = 400
        self.pub_imu_upd = args.publish_imu_updates

        self.p_odo = rospy.Publisher(args.pub_prefix + "/odometry", nm.Odometry, queue_size=50)
        self.p_t_img = rospy.Publisher(args.pub_prefix + "/image_track", sm.Image, queue_size=50)
        self.p_path = rospy.Publisher(args.pub_prefix + "/path", nm.Path, queue_size=50)
        self.p_kps = rospy.Publisher(args.pub_prefix + "/margin_cloud", sm.PointCloud, queue_size=50)
        self.p_akps = rospy.Publisher(args.pub_prefix + "/point_cloud", sm.PointCloud, queue_size=50)

        self.logger.info('Launching node...')
        level = self.logger.level

        # messes up logger, see https://github.com/ros/ros_comm/issues/1384
        rospy.init_node('vio_node')
        self.logger.setLevel(level)

        self.logger.info('Subscribing to ROS topic "%s" for images...' % args.cam_topic)
        self.s_cam = rospy.Subscriber(args.cam_topic, sm.Image, lambda x: self.frame_handler(x), queue_size=10)
        self.logger.info('Subscribing to ROS topic "%s" for IMU messages...' % args.imu_topic)
        self.s_imu = rospy.Subscriber(args.imu_topic, sm.Imu, lambda x: self.imu_handler(x), queue_size=1000)

    def close(self):
        self.s_imu.unregister()
        self.s_cam.unregister()
        self.odo.quit()
        self.odo = None

    def cam_in_world_frame(self, pose_cf_c2w):
        pose_cf_w2c = -pose_cf_c2w
        pose_bf_w2c = pose_cf_w2c.to_global(self.config.hw.b2c)
        pose_wf_w2c = pose_bf_w2c.to_global(self.config.hw.w2b)
        return pose_wf_w2c

    def kp_in_world_frame(self, pts3d_cf):
        wf2cf_q = self.config.hw.w2b.quat * self.config.hw.b2c.quat
        pts3d_wf = tools.q_times_mx(wf2cf_q, pts3d_cf)
        return pts3d_wf

    def frame_handler(self, m_img: sm.Image):
        ts = m_img.header.stamp.secs + m_img.header.stamp.nsecs / 1e9
        h, w = m_img.height, m_img.width
        assert m_img.step == w and m_img.encoding == 'mono8', 'wrong step size or image encoding'
        img = np.frombuffer(m_img.data, dtype=np.uint8).reshape((h, w))

        nf, *_ = self.odo.process(img, datetime.fromtimestamp(ts), measure=None)
        self.publish_odo(nf)
        self.publish_active_keypoints(nf)

        if self.to_rviz:
            self.publish_track_img()
            self.publish_path()
            self.publish_keypoints()

    def imu_handler(self, m_imu: sm.Imu):
        if hasattr(self.odo, 'new_imu'):
            ts = m_imu.header.stamp.secs + m_imu.header.stamp.nsecs / 1e9
            acc = [getattr(m_imu.linear_acceleration, c) for c in 'xyz']
            gyr = [getattr(m_imu.angular_velocity, c) for c in 'xyz']

            nf, *_ = self.odo.new_imu(acc, gyr, ts)

            if self.pub_imu_upd:
                self.publish_odo(nf)

    def publish_odo(self, nf: Frame):
        # /vins_estimator/odometry
        m_odo = nm.Odometry()
        m_odo.header.stamp = rospy.Time.now()  # or (?): rospy.Time.from_sec(nf.time.timestamp())
        m_odo.header.frame_id = self.vio_frame_id
        m_odo.child_frame_id = 'world'
        if nf.pose.post is not None:
            wf_pose = self.cam_in_world_frame(nf.pose.post)
            m_odo.pose.pose = gm.Pose(gm.Point(*wf_pose.loc),
                                      gm.Quaternion(**dict(zip('wxyz', wf_pose.quat.components))))
            # m_odo.twist.twist = gm.Twist(gm.Vector3(*wf_pose.vel), gm.Vector3(*wf_pose.angvel))
        self.p_odo.publish(m_odo)

    def publish_track_img(self):
        # /vins_estimator/image_track
        img = self.odo.curr_track_image
        if img is not None:
            m_img = sm.Image()
            m_img.header.stamp = rospy.Time.now()
            m_img.height = img.shape[0]
            m_img.width = img.shape[1]
            m_img.step = img.shape[1] * 3
            m_img.encoding = 'bgr8'
            m_img.data = img.flatten().tolist()
            self.p_t_img.publish(m_img)

    def publish_path(self):
        # /vins_estimator/path                      :
        m_path = nm.Path()
        m_path.header.stamp = rospy.Time.now()
        m_path.header.frame_id = self.vio_frame_id

        for kf in self.odo.all_keyframes():
            if kf.pose.post is not None:
                wf_pose = self.cam_in_world_frame(kf.pose.post)
                pose = gm.PoseStamped()
                pose.header.frame_id = m_path.header.frame_id
                pose.header.stamp = rospy.Time.from_sec(kf.time.timestamp())
                for k, v in zip('xyz', wf_pose.loc):
                    setattr(pose.pose.position, k, v)
                for k, v in zip('wxyz', wf_pose.quat.components):
                    setattr(pose.pose.orientation, k, v)
                m_path.poses.append(pose)

        self.p_path.publish(m_path)

    def publish_keypoints(self):
        # /vins_estimator/margin_cloud
        m_pc = sm.PointCloud()
        m_pc.header.stamp = rospy.Time.now()
        m_pc.header.frame_id = self.vio_frame_id

        for pt3d in self.kp_in_world_frame(self.odo.get_3d_map_pts()):
            m_pc.points.append(gm.Point32(*pt3d))

        self.p_kps.publish(m_pc)

    def publish_active_keypoints(self, nf: Frame):
        # /vins_estimator/point_cloud
        m_pc = sm.PointCloud()
        m_pc.header.stamp = rospy.Time.now()
        m_pc.header.frame_id = self.vio_frame_id

        visible_ids = set(nf.kps_uv.keys()).intersection(self.odo.state.map3d.keys())
        kp3d_wf = self.kp_in_world_frame(np.array([self.odo.state.map3d[kp_id].pt3d for kp_id in visible_ids]))
        for pt3d in kp3d_wf:
            m_pc.points.append(gm.Point32(*pt3d))

        self.p_akps.publish(m_pc)

    @staticmethod
    def _parse_config(args):
        def_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), 'config')

        config = Configuration()
        config.hw = Configuration(args.hw_config, def_path=def_path)
        config.vio = Configuration(args.vio_config, def_path=def_path)

        for k, v in args.__dict__.items():
            if k in config.hw:
                config.hw[k] = v
            elif k in config.vio:
                config.vio[k] = v

        config.hw.cam.mx = np.array(config.hw.cam.mx).reshape((3, 3))
        config.hw.imu = Configuration(config.hw.imu_config, def_path=def_path)
        config.hw.w2b = Pose.from_mx(np.array(config.hw.w2b))
        config.hw.b2c = Pose.from_mx(np.array(config.hw.b2c))
        return config


if __name__ == '__main__':
    main()
